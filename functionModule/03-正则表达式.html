<!-- 正则表达式 -->
<script>
    // 目录
    /**  */
    function fun001();


    // -------------------------------------
    /**  */
    function fun001(){
        // JavaScript中使用正则表达式的两种方式：
        {`
            JavaScript通过内置对象RegExp支持正则表达式，有两种方式实例化RegExp对象：
            字面量
            构造函数
            －－－－－－
            字面量方式：
            var reg = /\bis\b/g;    //  '\b'表示单词边界；'g'表示全局搜索；两个'/'之间时匹配规则。
            myString.replace(reg, 'IS');    //用'IS'替换通过正则reg匹配到的内容。
            －－－－－－
            构造函数方式：
            var reg = new RegExp('\\bis\\b','g');   // 参数1:正则表达式的文本内容，反斜线是特殊字符，所以要在用一个反斜线转译一下。参数2:修饰符。
            myString.replace(reg, 'IS');    //用'IS'替换通过正则reg匹配到的内容。

        `}

        // 正则表达式的修饰符
        {`
            g   :   global,全文搜索。不添加，搜索到第一个匹配停止。
            i   :   ignore case,忽略大小写，默认大小写敏感。
            m   :   multiple lines,多行搜索。
        `}

        // 两种基本字符类型：[原义文本字符][元字符]
        {
            // 元字符：具有特殊含义的非字母字符
            {`
                水平制表符  \t
                垂直制表符  \v
                换行符      \n
                回车符      \t
                空字符      \0
                换页符      \f
                Ctrl+X      \cX
            `}
            
            // 字符类:符合某些特征的对象，泛指，并非特指某个字符
            {`
                [abc]     // 表示：匹配字符 a 或 b 或 c 的单个字母字符
                    myString.replace(/[a,b,c]/g, 'X');    // 全局匹配是a／b／c的单个字符,并将其替换成X
            `}

            // 字符类取反:使用元字符 ^ 创建 反向类／负向类：意思是不属于某类的内容
            {`
                [^abc]     // 表示：匹配 不是字符 a 或 b 或 c 的单个字母字符
                    myString.replace(/[^abc]]/g, 'X');    // 全局匹配不是a/b/c的单个字符,并将其替换成X
            `}

            // 范围类:闭区间，包含两个端点。在[]组成的类内部，是可以连写的。
            {`
                [a-z]     // 表示：从 a 到 z 的任意单个字符，包含a和z本身。
                    myString.replace(/[a-z]]/g, 'X');    // 全局匹配任意一个在 a-z 之间的单个字符,并将其替换成X
                －－－－－－
                [a-zA-Z]    // 大小写完全匹配
                    - 表示范围的意思:
                        如果需要匹配 2021-05-17 中的 1- 5- ，则写成 [0-9-]
                        如果需要匹配 2021-05-17 中的 -0 -1 ，则写成 [-0-9]

            `}

            // 预定义类
            {
                // 字符      等价类          含义
                `
                    .       [^\r\n]         除了 回车符 和 换行符 之外的所有字符
                    \d      [0-9]           数字字符
                    \D      [^0-9]          非数字字符
                    \s      [\t\n\x0B\f\r]  空白符
                    \S      [^\t\n\x0B\f\r] 非空白符
                    \w      [a-zA-Z_0-9]    单词字符（字母、数字、下划线）
                    \W      [^a-zA-Z_0-9]   非单词字符（非 字母、数字、下划线）
            `}

            // 边界字符
            {
                // 字符      含义
                `
                    ^       以xxx开始
                    $       以xxx结束
                    \b      单词边界
                    \B      非单词边界
            `}

            // 量词，作用于其紧挨着的字符或分组
            {
                // 字符      含义
                `
                    ?       最多出现一次：出现0次或1次
                    +       最少出现一次：出现1次或多次
                    *       出现任意次：  出现0次或多次
                    {n}     出现 n 次
                    {n,m}   出现 n 到 m 次，包含边界
                    {n,}    至少出现 n 次
                `
                // 注意1：是否需要贪婪
                `
                    贪婪模式：  尽可能多的匹配。正则表达式默认为贪婪模式。
                        '123456789'.match(/\d{3,5}/g);  // 匹配结果：["12345"]
                    非贪婪模式：尽可能少的匹配。量词后面加上?即可。
                        '123456789'.match(/\d{3,5}/g);  // 匹配结果：["123","456","789"]
                `
                // 注意2：是否需要分组,使用 ()
                `
                    Byron{3}    // 含义是 n重复3次，并不是 Byron重复3次。
                    (Byron){3}  // 表示的才是 Byron重复3次。
                `
                    
            }

            // 分组：使用 () 实现分组
            {
                // 1、使得量词作用于分组
                `
                    (Byron){3}
                    'a1b2c3d4'.replace(/[a-z]\d{3}/g,'X');      // "a1b2c3d4"
                    'a1b2c3d4'.replace(/([a-z]\d){3}/g,'X');    // "Xd4"

                `
                // 2、或，使用 | 可以达到 或 的效果。
                `
                    2.1、将正则表达式的两边整个分开
                        Byron|Casper  // 表示的就是 Byron 或 Casper
                    2.2、不想将整个表达式都分开，只是表达式的某部分存在 或 的关系：用分组
                        Byr(on|Ca)sper  // 表示的就是 Byronsper 或 ByrCasper
                        "ByronsperByrCasper".replace(/Byr(on|Ca)sper/g,'X');    //"XX"

                `
                // 3、［捕获分组］反向引用：$1$2$3 分别代表的是 第1、2、3个分组匹配到的内容.
                `
                    需求：2021-05-07 ==> 05/07/2021
                    '2021-05-07'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$1');  // "2021"
                    '2021-05-07'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2/$3/$1');  // "05/07/2021"
                `
                // 4、［忽略分组］在分组内加上 ?: 就可以忽略对某些分组的捕获。
                `
                    (?:Byron).(ok)  // 此时$1捕获的将是 (ok) 这个分组。
                    '2021-05-07'.replace(/(?:\d{4})-(\d{2})-(\d{2})/g,'$1');  // "05"

                `
            }
        
        }



    }





</script>